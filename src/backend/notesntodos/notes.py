"""
notes.py - Note and NoteCollection classes for Notes'n'Todos

MIT license - see LICENSE file in Notes'n'Todos project root

The Note and NoteCollection classes take care of:

- Loading and saving of notes
- Parsing new notes and keeping track of the state of a notebook
- Providing content to the web API including converting markdown to HTML with tweaks to make 
  task list items clickable

pip installs required:
  markdown
  pymdown-extensions

Copyright 2021 - Lars Ole Pontoppidan <contact@larsee.com>

"""

import os
import re
from datetime import datetime
import markdown
import urllib
from .onchange_tasklist import OnChangeTlExtension


# ----- Config -----

FILE_EXTENSION = "md"
MARKDOWN_EXTENSIONS = [
    OnChangeTlExtension(onchange_code="nnt.checkClick(this,%d)"),
    "pymdownx.saneheaders",
    "pymdownx.magiclink",
    "fenced_code",
    "tables",
    "def_list",
    "sane_lists",
]
MARKDOWN_EXTCONFIG = {}

# ----- Note system -----

"""
Edit keywords:

date: X                  <-- will be removed and used in filename
name: X                  <-- will be removed and used in filename
tags: X, X, X, ...       <-- will stay in note
"""

DateRegex = re.compile(r"^\d\d\d\d-\d\d-\d\d$")


def checkDateFormat(s):
    return not DateRegex.match(s) is None


def encodeFilename(filename):
    # This filename encoder is not super strict, use with caution
    filename = filename.strip()
    out = ""
    for c in filename:
        if c in '\\/:*?"<>|%':
            out += urllib.parse.quote(c, safe="")
        else:
            out += c
    return out


def decodeFilename(filename):
    return urllib.parse.unquote(filename)


def makeTimestamp():
    date = datetime.now()
    return date.strftime("%Y-%m-%d")


def splitFilename(x):
    if " " in x:
        return x.split(" ", 1)
    else:
        return (x, "")


def splitCheckDate(full_date):
    if "." in full_date:
        (date, after_dot) = full_date.split(".", 1)
        try:
            index = int(after_dot)
        except:
            raise ValueError("Invalid date format: " + full_date)
    else:
        date = full_date
        index = 0

    if not checkDateFormat(date):
        raise ValueError("Invalid date format: " + full_date)

    return (date, index)


def assembleDate(date, date_index):
    if date_index > 0:
        return "%s.%d" % (date, date_index)
    else:
        return date


MatchHyperLinkRe = re.compile("<a (.*?)>")


def makeLinksNoReferrer(html):
    return MatchHyperLinkRe.sub(r'<a \1 rel="noreferrer">', html)


def makeHtml(src):
    # Remove the tags:<...> lines from note
    no_tags = FindTagsRe.sub("", src, count=1)
    html = markdown.markdown(
        no_tags, extensions=MARKDOWN_EXTENSIONS, extension_configs=MARKDOWN_EXTCONFIG
    )
    return makeLinksNoReferrer(html)


# ------


MdCheckCandidateRe = re.compile("\[[ xX]\] ")
HtmlCheckTokenRe = re.compile(
    re.escape('<span class="task-list-indicator"></span></label> ') + "¤(\d\d\d)д¤"
)


class TokenMaker:
    def __init__(self):
        self.count = 0
        self.offsets = []

    def makeToken(self, match):
        # Record offset to the next character after [ to get the space, x or X of the check
        self.offsets.append(match.start() + 1)
        # Return the match appended with numbered token
        ret = "%s¤%03dд¤" % (match.group(0), self.count)
        self.count += 1
        return ret


def findCheckOffsets(s):
    """Find the text offset of each task list item in the src.
    There is no easy and elegant way to do this. This approach uses extra tokens in the md src
    """

    # First step is to insert numbered tokens at each check box candidate
    tm = TokenMaker()
    tokenized_src = MdCheckCandidateRe.sub(tm.makeToken, s)

    # Convert markdown to html
    html = markdown.markdown(
        tokenized_src,
        extensions=MARKDOWN_EXTENSIONS,
        extension_configs=MARKDOWN_EXTCONFIG,
    )

    # Go through the resulting check boxes and from the token index we know what offset in src
    # lead to the check box:
    offsets = []
    for match in HtmlCheckTokenRe.finditer(html):
        offsets.append(tm.offsets[int(match.group(1))])

    return offsets


# ------

FindTagsRe = re.compile("^tags:(.*)$", flags=re.MULTILINE)

# Regex to find unchecked task list items generated by markdown. First group is the index
# from the parameter to the javascript function. Second group is the task text, until end
# paragraph or end list tag.
FindUncheckedHtmlRe = re.compile(
    ",(\d+)"
    + re.escape(')"/><span class="task-list-indicator"></span></label>')
    + "(.*?)\</(p\>|li\>)"
)


class Note:
    def __init__(self):
        self.Tags = set()
        self.Name = ""
        self.Date = ""
        self.DateIndex = 0
        self.Todos = []
        self.Note = ""

    @staticmethod
    def load(path, filename):
        ret = Note()
        ret._load(path, filename)
        return ret

    @staticmethod
    def Parse(note_text):
        if len(note_text) == 0:
            return None
        ret = Note()
        ret._parse(note_text)
        return ret

    def getFullname(self):
        date = assembleDate(self.Date, self.DateIndex)
        if len(self.Name) > 0:
            return "%s %s" % (date, self.Name)
        else:
            return date

    def getSortingName(self):
        return "%s.%02d %s" % (self.Date, self.DateIndex, self.Name)

    def getFilename(self):
        return encodeFilename(self.getFullname() + "." + FILE_EXTENSION)

    def getNoteObj(self, src=False, todos=False, html=False):
        ret = {
            "date": self.Date,
            "name": self.Name,
            "fullname": self.getFullname(),
            "tags": sorted(self.Tags),
        }
        if todos:
            ret["todos"] = self.Todos
        if src:
            ret["src"] = self.FullSrc
            ret["check_offsets"] = self.CheckOffsets
        if html:
            ret["html"] = self.Html
        return ret

    def Save(self, filename):
        with open(filename, "w") as file:
            file.write(self.Note)

    def _setNote(self, src):
        self.Note = src
        self.Html = makeHtml(src)
        self.FullSrc = "date: %s\nname: %s\n%s" % (
            assembleDate(self.Date, self.DateIndex),
            self.Name,
            self.Note,
        )
        try:
            self.CheckOffsets = findCheckOffsets(self.FullSrc)
        except:
            self.CheckOffsets = []

        tags_match = FindTagsRe.search(src)
        if tags_match:
            self.Tags = set([x.strip() for x in tags_match.group(1).split(",")])
            if "" in self.Tags:
                self.Tags.remove("")

        # Identify unchecked todos
        self.Todos = []
        for match in FindUncheckedHtmlRe.finditer(self.Html):
            try:
                index = int(match.group(1))
            except:
                index = -1
            self.Todos.append((match.group(2).strip(), index))

    def _load(self, path, filename):
        # Derive Name, Date, DateIndex from the filename:
        if not filename.endswith("." + FILE_EXTENSION):
            raise ValueError("Filename has wrong extension")

        (date, name) = splitFilename(filename[:-3])
        (self.Date, self.DateIndex) = splitCheckDate(date)
        self.Name = decodeFilename(name)

        if filename != self.getFilename():
            raise ValueError("Filename fails validation")

        # Set note body from file contents:
        with open(path + filename) as file:
            self._setNote(file.read())

    def _parse(self, note_src):
        # Derive Name, Date, DateIndex from note_src:
        self.Date = ""
        filtered_lines = []
        for line in note_src.split("\n"):
            if line.startswith("name:"):
                self.Name = line.split(":", 1)[1].strip()
                line = None
            elif line.startswith("date:"):
                date = line.split(":", 1)[1].strip()
                (self.Date, self.DateIndex) = splitCheckDate(date)
                line = None
            if not line is None:
                filtered_lines.append(line)

        if len(self.Date) == 0:
            # No date provided in note, set current day
            self.Date = makeTimestamp()

        # Set note body from filtered note_src:
        self._setNote("\n".join(filtered_lines))


class NoteCollection:
    def __init__(self, path):
        # Path must end with "/"
        self.Path = path
        self.Notes = []
        self.AllTags = set()
        self.PreFileChangeCallback = None

    def setPreFileChangeCallback(self, prefilechange_callback):
        self.PreFileChangeCallback = prefilechange_callback

    def sortNotes(self):
        def sortFunc(e):
            return e.getSortingName()

        self.Notes.sort(key=sortFunc, reverse=True)

    def _add(self, note):
        self.Notes.append(note)
        self.AllTags.update(note.Tags)

    def _remove(self, note):
        self.Notes.remove(note)
        # This might have removed a tag, no other way than to gather tags again
        self.AllTags = set()
        for note in self.Notes:
            self.AllTags.update(note.Tags)

    def loadAll(self):
        self.Notes = []

        for filename in os.listdir(self.Path):
            if filename.endswith("." + FILE_EXTENSION):
                try:
                    note = Note.load(self.Path, filename)
                    self._add(note)
                except Exception as e:
                    print("Couldn't load note %s: %s" % (filename, str(e)))

        self.sortNotes()
        return len(self.Notes)

    def findFromFilename(self, filename):
        for note in self.Notes:
            if note.getFilename() == filename:
                return note
        return None

    def findFromFullname(self, fullname):
        for note in self.Notes:
            if note.getFullname() == fullname:
                return note
        return None

    def findNextDateIndex(self, date):
        i = -1
        for note in self.Notes:
            if note.Date == date and note.DateIndex > i:
                i = note.DateIndex
        return i + 1

    def findDate(self, date, date_index):
        for note in self.Notes:
            if note.Date == date and note.DateIndex == date_index:
                return True
        return False

    def addNote(self, note, old_fullname=None):
        # Check if we need to replace an old note
        if not old_fullname is None:
            rm_note = self.findFromFullname(old_fullname)
            if rm_note != None:
                self._remove(rm_note)
                try:
                    note_fn = rm_note.getFilename()
                    if self.PreFileChangeCallback:
                        self.PreFileChangeCallback(note_fn)
                    os.unlink(self.Path + note_fn)
                except Exception as e:
                    # raise Exception("Failed to delete note: %s, %s" % (old_fullname, str(e)))
                    print("Failed to delete note: %s, %s" % (old_fullname, str(e)))

        # Adding a None note is equivalent to deleting it
        if not note is None:
            if self.findDate(note.Date, note.DateIndex):
                note.DateIndex = self.findNextDateIndex(note.Date)

            # Add new note and save it
            try:
                note_fn = note.getFilename()
                if self.PreFileChangeCallback:
                    self.PreFileChangeCallback(note_fn)
                note.Save(self.Path + note_fn)
                self._add(note)
            except Exception as e:
                raise Exception("Failed save note: %s" % str(e))
            self.sortNotes()

    def getNotes(self, tags_filter=None):
        ret = []
        for note in self.Notes:
            if tags_filter is None or (len(note.Tags & tags_filter) > 0):
                # No filter or at least one tag match
                ret.append(note)
        return ret

    def getNote(self, full_name):
        for note in self.Notes:
            if note.getFullname() == full_name:
                return note
        return None

    def getAllTags(self):
        return sorted(self.AllTags)


# ---- Tests


def testFindCheckOffsets():
    src = "- [ ] This is some text\n   - [x] some more text [ ] a false check\n* - [X] and a final check\n- [x ] this is not a check"
    offsets = findCheckOffsets(src)
    assert len(offsets) == 3
    assert src[offsets[0]] == " "
    assert src[offsets[1]] == "x"
    assert src[offsets[2]] == "X"


def testFindUncheckedHtmlRe():
    src = "- [ ] This is some text\n   - [x] some more text [ ] a false check\n* - [ ] check with www.link.test\n- [x ] this is not a check"
    html = makeHtml(src)
    matches = [x for x in FindUncheckedHtmlRe.finditer(html)]
    assert len(matches) == 2
    assert matches[0].group(1) == "0"
    assert matches[0].group(2).strip() == "This is some text"
    assert matches[1].group(1) == "2"
    assert matches[1].group(2).strip().startswith("check with <a href")
    assert matches[1].group(2).strip().endswith("</a>")


def testFindUncheckedHtmlRe2():
    src = """- [ ] Check1
- [ ] Check2
- [ ] Check3

- [ ] Check4"""
    html = makeHtml(src)
    matches = [x for x in FindUncheckedHtmlRe.finditer(html)]
    assert len(matches) == 4


def testMakeNoreferrerLinks():
    src = "Some random www.link.test\n"
    html = makeHtml(src)
    assert ' <a href="http://www.link.test" rel="noreferrer">www.link.test</a>' in html


def testsRun():
    testFindCheckOffsets()
    testFindUncheckedHtmlRe()
    testFindUncheckedHtmlRe2()
    testMakeNoreferrerLinks()
